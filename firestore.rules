
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to check if a user is an admin
    function isAdmin() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }

    // Helper function to check if the user is the owner of the data
    function isOwner(userId) {
      return request.auth != null && request.auth.uid == userId;
    }

    // Users can only read/write their own data. Admins can do anything.
    match /users/{userId} {
      allow read, write: if isOwner(userId) || isAdmin();
    }

    // Game settings can be read by any authenticated user, but only written by admins.
    // This is crucial for the app to load game rules.
    match /game-settings/{setting} {
        allow get, list: if request.auth != null;
        allow write: if isAdmin();
    }

    // Titles can be read by any authenticated user, but only written by admins.
    match /titles/{titleId} {
        allow read: if request.auth != null;
        allow write: if isAdmin();
    }
    
    // Alliances can be read by any authenticated user.
    // Only admins or alliance leaders (future implementation) can write.
    match /alliances/{allianceId} {
        allow read: if request.auth != null;
        allow write: if isAdmin(); // To be refined later for leaders
    }

    // Votes can be created/updated by the voter, read by anyone authenticated.
    match /votes/{userId} {
        allow read: if request.auth != null;
        allow create, update: if isOwner(userId);
        allow delete: if isAdmin();
    }

    // Reports can only be read by users involved in the report.
    match /reports/{reportId} {
        allow read: if request.auth != null && request.auth.uid in resource.data.involvedUsers;
        allow write: if false; // Reports should be created by server/functions, not clients
    }
    
    // Activity log is write-only for authenticated users. Read by admins.
    match /activityLog/{logId} {
        allow read: if isAdmin();
        allow create: if request.auth != null;
    }

    // Queues (construction, training, attack, return, transport) are write-only for the user themselves.
    match /constructionQueue/{jobId} {
        allow read: if request.auth.uid == resource.data.userId;
        allow create: if request.auth.uid == request.resource.data.userId;
        allow delete: if false; // Deletion is handled by background tasks
    }
    
    match /trainingQueue/{jobId} {
        allow read: if request.auth.uid == resource.data.userId;
        allow create: if request.auth.uid == request.resource.data.userId;
        allow delete: if false; 
    }
    
    match /attackQueue/{jobId} {
        allow read: if request.auth.uid == resource.data.attackerId;
        allow create: if request.auth.uid == request.resource.data.attackerId;
        allow delete: if false;
    }

    match /returnQueue/{jobId} {
        allow read: if request.auth.uid == resource.data.userId;
        allow create: if false; // Created by server logic
        allow delete: if false;
    }
    
    match /transportQueue/{jobId} {
        allow read: if request.auth.uid == resource.data.senderId || request.auth.uid == resource.data.recipientId;
        allow create: if request.auth.uid == request.resource.data.senderId;
        allow delete: if false;
    }

    // Ongoing wars can be read by anyone authenticated.
    match /wars/{warId} {
        allow read: if request.auth != null;
        allow create: if request.auth != null; // Leader should be verified in app logic
        allow delete: if isAdmin(); // Only admin can end a war forcefully
    }
    
  }
}
